## Synchronized
### 锁住当前对象
当时用synchronized修饰静态方法时，锁住的是class
当时用synchronized修饰非静态方法时，锁住的是对象

用synchronized修饰的代码块，编译阶段会在方法执行前后生成monitorenter、monitorexit指令  
当修饰方法会在常量池生成ACC_SYNCHRONIZED

### 锁升级
jdk1.6引入了锁优化，替代了原来只有重量级锁性能较差的问题。

偏向锁 -> 轻量级锁 -> 重量级锁

### 偏向锁
偏向锁是jdk1.6引入的一项锁优化，其中的“偏”是偏心的偏。它的意思就是说，这个锁会偏向于第一个获得它的线程，在接下来的执行过程中，假如该锁没有被其他线程所获取，没有其他线程来竞争该锁，那么持有偏向锁的线程将永远不需要进行同步操作。  
**即：在此线程之后的执行过程中，如果再次进入或者退出同一段同步块代码，并不再需要去进行加锁或者解锁操作** ，而是会做以下的步骤：

1) Load-and-test，也就是简单判断一下当前线程id是否与Markword当中的线程id是否一致.
1) 如果一致，则说明此线程已经成功获得了锁，继续执行下面的代码.
1) 如果不一致，则要检查一下对象是否还是可偏向，即“是否偏向锁”标志位的值。
1) 如果还未偏向，则利用CAS操作来竞争锁，也即是第一次获取锁时的操作。

假如有两个线程来竞争该锁话，那么偏向锁就失效了，进而升级成轻量级锁了。  
也就是**锁膨胀**。

### 锁撤销
由于偏向锁失效了，那么接下来就得把该锁撤销，锁撤销的开销花费还是挺大的，其大概的过程如下：

1) 在一个安全点停止拥有锁的线程。
1) 遍历线程栈，如果存在锁记录的话，需要修复锁记录和Markword，使其变成无锁状态。
1) 唤醒当前线程，将当前锁升级成轻量级锁。

所以，如果某些同步代码块大多数情况下都是有两个及以上的线程竞争的话，那么偏向锁就会是一种累赘，对于这种情况，我们可以一开始就把偏向锁这个默认功能给关闭（关闭偏向锁:-XX:-UseBiasedLocking）。

### 轻量级锁
包含两种
1) 自旋锁
1) 自适应自旋锁

偏向锁是同一个线程多次获取锁，轻量级锁是多个线程交替获取锁。相同点是假定都不存在锁竞争

#### 自适应自旋锁
由于线程1刚刚获得过该锁，那么虚拟机觉得线程1这次自旋也是很有可能能够再次成功获得该锁的，所以会延长线程1自旋的次数。

如果对于某一个锁，一个线程自旋之后，很少成功获得该锁，那么以后这个线程要获取该锁时，是有可能直接忽略掉自旋过程，直接升级为重量级锁的，以免空循环等待浪费资源。

### 重量级锁
轻量级锁膨胀之后，就升级为重量级锁了。重量级锁是依赖对象内部的monitor锁来实现的，而monitor又依赖操作系统的MutexLock(互斥锁)来实现的，所以重量级锁也被成为**互斥锁**。

当系统检查到锁是重量级锁之后，会把等待想要获得锁的线程进行阻塞，被阻塞的线程不会消耗cup。但是阻塞或者唤醒一个线程时，都需要操作系统来帮忙，这就需要从用户态转换到内核态，而转换状态是需要消耗很多时间的，有可能比用户执行代码的时间还要长。