## 1. 五大内存区域

- ### 方法区
  属于共享内存区域，存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
  
  **运行时常量池**，属于方法区的一部分，用于存放编译期生成的各种字面量和符号引用。
  
  
  
- ### 堆
  线程共享，主要是存放对象实例和数组。
  年轻代（New）：年轻代用来存放JVM刚分配的Java对象
  年老代（Tenured)：年轻代中经过垃圾回收没有回收掉的对象将被Copy到年老代
  永久代（Perm）：永久代存放Class、Method元信息，其大小跟项目的规模、类、方法的量有关，一般设置为128M就足够，设置原则是预留30%的空间。
  
  
  
- ### 虚拟机栈
  线程私有。
  每个方法在执行时都会床创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。
  

  
- ### 本地方法栈
  存放Native方法。
  
  
  
- ### 程序计数器
  线程私有，**唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。**

> 我们知道对于一个处理器(如果是多核cpu那就是一核)，在一个确定的时刻都只会执行一条线程中的指令，一条线程中有多个指令，为了线程切换可以恢复到正确执行位置，每个线程都需有独立的一个程序计数器，不同线程之间的程序计数器互不影响，独立存储。
> 注意：如果线程执行的是个java方法，那么计数器记录虚拟机字节码指令的地址。如果为native【底层方法】，那么计数器为空。

## 对象的内存布局

在 HotSpot 虚拟机中，分为 3 块区域：对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)



## 垃圾回收算法

- 标记-清除（Mark-Sweep）
  GC分为两个阶段，标记和清除。首先标记所有可回收的对象，在标记完成后统一回收所有被标记的对象。同时会产生不连续的内存碎片。碎片过多会导致以后程序运行时需要分配较大对象时，无法找到足够的连续内存，而不得已再次触发GC。
- 复制（Copy）
  将内存按容量划分为两块，每次只使用其中一块。当这一块内存用完了，就将存活的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。这样使得每次都是对半个内存区回收，也不用考虑内存碎片问题，简单高效。缺点需要两倍的内存空间。
- 标记-整理（Mark-Compact） 也分为两个阶段，首先标记可回收的对象，再将存活的对象都向一端移动，然后清理掉边界以外的内存。此方法避免标记-清除算法的碎片问题，同时也避免了复制算法的空间问题。 一般年轻代中执行GC后，会有少量的对象存活，就会选用复制算法，只要付出少量的存活对象复制成本就可以完成收集。而老年代中因为对象存活率高，没有额外过多内存空间分配，就需要使用标记-清理或者标记-整理算法来进行回收。

## 垃圾收集器

- 串行收集器（Serial） 比较老的收集器，单线程。收集时，必须暂停应用的工作线程，直到收集结束。
- 并行收集器（Parallel） 多条垃圾收集线程并行工作，在多核CPU下效率更高，应用线程仍然处于等待状态。
- CMS收集器（Concurrent Mark Sweep） CMS收集器是缩短暂停应用时间为目标而设计的，是基于标记-清除算法实现，整个过程分为4个步骤，包括： 初始标记（Initial Mark） 并发标记（Concurrent Mark） 重新标记（Remark） 并发清除（Concurrent Sweep） 其中，初始标记、重新标记这两个步骤仍然需要暂停应用线程。初始标记只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段是标记可回收对象，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作导致标记产生变动的那一部分对象的标记记录，这个阶段暂停时间比初始标记阶段稍长一点，但远比并发标记时间段。 由于整个过程中消耗最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，CMS收集器内存回收与用户一起并发执行的，大大减少了暂停时间。
- G1收集器（Garbage First） G1收集器将堆内存划分多个大小相等的独立区域（Region），并且能预测暂停时间，能预测原因它能避免对整个堆进行全区收集。G1跟踪各个Region里的垃圾堆积价值大小（所获得空间大小以及回收所需时间），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region，从而保证了再有限时间内获得更高的收集效率。 G1收集器工作工程分为4个步骤，包括：

## 垃圾收集器参数

| 参数                                   | 描述                                                         |
| -------------------------------------- | ------------------------------------------------------------ |
| -XX:+UseSerialGC                       | 串行收集器                                                   |
| -XX:+UseParallelGC                     | 并行收集器                                                   |
| -XX:+UseParallelGCThreads=8            | 并行收集器线程数，同时有多少个线程进行垃圾回收，一般与CPU数量相等 |
| -XX:+UseParallelOldGC                  | 指定老年代为并行收集                                         |
| -XX:+UseConcMarkSweepGC                | CMS收集器（并发收集器）                                      |
| -XX:+UseCMSCompactAtFullCollection     | 开启内存空间压缩和整理，防止过多内存碎片                     |
| -XX:CMSFullGCsBeforeCompaction=0       | 表示多少次Full GC后开始压缩和整理，0表示每次Full GC后立即执行压缩和整理 |
| -XX:CMSInitiatingOccupancyFraction=80% | 表示老年代内存空间使用80%时开始执行CMS收集，防止过多的Full GC |
| -XX:+UseG1GC                           | G1收集器                                                     |
| -XX:MaxTenuringThreshold=0             | 在年轻代经过几次GC后还存活，就进入老年代，0表示直接进入老年代 |

## Surviver垃圾回收机制

Eden space gc后存活对象进入s0中，然后清空Eden space 下一次minor gc会把Eden space中存活的对象和s0中存活的对象放入s1中，其中s0中存活的对象年龄+1,该过程中年龄过大的对象会进入年老代